<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCA BOT // ORCHESTRATOR</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; font-size: 14px; }
        .box { border: 1px solid #333; padding: 15px; margin-bottom: 20px; border-radius: 8px; }
        h1 { color: #ff005a; font-size: 1.2rem; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        h3 { margin-top: 0; color: #fff; font-size: 1rem; }
        input { background: #111; color: #fff; border: 1px solid #333; padding: 12px; width: 100%; box-sizing: border-box; margin-bottom: 10px; border-radius: 4px; }
        button { background: #ff005a; color: white; padding: 15px; width: 100%; border: none; font-weight: bold; cursor: pointer; border-radius: 4px; font-size: 16px; }
        button:active { background: #d0004b; }
        .log-container { height: 300px; overflow-y: scroll; border: 1px dashed #333; padding: 10px; background: #050505; }
        .log-entry { margin-bottom: 5px; border-bottom: 1px solid #111; padding-bottom: 2px; word-break: break-all; }
        .success { color: #0f0; } 
        .error { color: #f00; background: rgba(255,0,0,0.2); } 
        .alert { color: #ff005a; }
        .info { color: #888; }
    </style>
</head>
<body>
    <h1>ü§ñ BCA BOT CONTROLLER</h1>
    
    <div class="box">
        <h3>1. AUTHENTICATION</h3>
        <input type="text" id="tg-token" placeholder="Telegram Bot Token">
        <input type="text" id="admin-id" placeholder="Your Telegram User ID">
        <button onclick="handleAuthClick()">üöÄ START SYSTEM</button>
    </div>

    <div class="box">
        <h3>2. LIVE LOGS</h3>
        <div id="console" class="log-container">
            <div class="log-entry info">System initialized. Waiting for user...</div>
        </div>
    </div>

    <!-- Silent Audio to keep browser tab awake -->
    <audio id="bg-audio" loop>
        <source src="https://github.com/anars/blank-audio/raw/master/10-minutes-of-silence.mp3" type="audio/mp3">
    </audio>

    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>

    <script>
        // --- CONFIGURATION (FILL THESE) ---
        const GOOGLE_CLIENT_ID = '164525854794-ifjc93mal53e6tj6vikaj1aqkci0ru81.apps.googleusercontent.com'; 
        const GOOGLE_API_KEY = 'AIzaSyBUK6-7P_vIrOYHQfoCmiWg6JtiV2NXqFs'; 
        const DRIVE_FOLDER_ID = '1nIjmJk1UKxsJEnMZujZ5BhZf9HW13d1S';
        const DB_FILE_ID = '1wcPqjXJyTi9m9HrZUbMHOEj78x_6_534';
        // ----------------------------------

        let tokenClient;
        let lastUpdateId = 0;
        let isPolling = false;

        // --- GLOBAL ERROR HANDLING ---
        window.onerror = function(msg, url, line) {
            log(`CRITICAL ERROR: ${msg} (Line ${line})`, 'error');
            return false;
        };

        // --- LOAD SAVED CREDENTIALS ---
        window.onload = function() {
            document.getElementById('tg-token').value = localStorage.getItem('tg_token') || '';
            document.getElementById('admin-id').value = localStorage.getItem('admin_id') || '';
            
            gapi.load('client', async () => {
                await gapi.client.init({ apiKey: GOOGLE_API_KEY, discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] });
                log("Google API Loaded.", "info");
            });

            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/drive.file',
                callback: (resp) => {
                    if (resp.error) {
                        log("Auth Error: " + JSON.stringify(resp), 'error');
                        return;
                    }
                    log("‚úÖ Auth Success! Initializing Bot...", "success");
                    startBotEngine();
                }
            });
        };

        function handleAuthClick() {
            const tg = document.getElementById('tg-token').value;
            const ad = document.getElementById('admin-id').value;
            
            if(!tg || !ad) return alert("Please fill in Telegram details.");
            localStorage.setItem('tg_token', tg);
            localStorage.setItem('admin_id', ad);
            tokenClient.requestAccessToken({prompt: ''});
        }

        function startBotEngine() {
            try {
                const audio = document.getElementById('bg-audio');
                audio.play().catch(e => log("‚ö†Ô∏è Tap screen to enable background mode.", "info"));
            } catch (e) { console.log(e); }

            if (!isPolling) {
                isPolling = true;
                log("üì° Bot is ONLINE and Polling Telegram...", "success");
                pollTelegram();
            }
        }

        // --- TELEGRAM LOGIC ---
        async function pollTelegram() {
            const tgToken = document.getElementById('tg-token').value;
            const adminId = document.getElementById('admin-id').value;

            try {
                const url = `https://api.telegram.org/bot${tgToken}/getUpdates?offset=${lastUpdateId + 1}&timeout=10`;
                const resp = await fetch(url);
                const data = await resp.json();

                if (data.ok && data.result) {
                    for (const update of data.result) {
                        lastUpdateId = update.update_id;
                        await processMessage(update.message, tgToken, adminId);
                    }
                }
            } catch (e) {
                // Ignore network timeouts, they are normal in polling
                if(!e.message.includes("Failed to fetch")) log("Polling Info: " + e.message, "info");
            }

            setTimeout(pollTelegram, 2000); 
        }

        async function processMessage(msg, token, adminId) {
            if (!msg || String(msg.from.id) !== String(adminId)) return;

            if (msg.text === '/start') {
                return sendMessage(msg.chat.id, "ü§ñ <b>BCA Bot Online.</b>\nSend file + Caption (#DBMS, #C, #Math)", token);
            }

            if (msg.document || msg.photo || msg.video) {
                const fileObj = msg.document || msg.video || (msg.photo ? msg.photo[msg.photo.length - 1] : null);
                const caption = msg.caption || "";
                
                let category = "General";
                if(caption.toLowerCase().includes("dbms")) category = "DBMS";
                else if(caption.toLowerCase().includes("c pro")) category = "Programming in C";
                else if(caption.toLowerCase().includes("data")) category = "Data Structures";
                else if(caption.toLowerCase().includes("math")) category = "Mathematics";

                log(`üì• Processing: ${fileObj.file_name || 'Image'}`, "alert");
                sendMessage(msg.chat.id, `‚è≥ <b>Downloading...</b>\nCategory: ${category}`, token);

                try {
                    await handleFileUpload(fileObj, caption, category, msg.chat.id, token);
                } catch (e) {
                    log("‚ùå ERROR: " + e.message, "error");
                    sendMessage(msg.chat.id, "‚ùå Error: " + e.message, token);
                }
            }
        }

        async function handleFileUpload(fileObj, caption, category, chatId, token) {
            // 1. Get Path
            const pathRes = await fetch(`https://api.telegram.org/bot${token}/getFile?file_id=${fileObj.file_id}`);
            const pathJson = await pathRes.json();
            
            if (pathJson.result.file_size > 20 * 1024 * 1024) throw new Error("File > 20MB. Too large for browser bot.");

            // 2. Download via CORS PROXY (THE FIX)
            // We use corsproxy.io to bypass the Telegram restriction
            const rawTelegramUrl = `https://api.telegram.org/file/bot${token}/${pathJson.result.file_path}`;
            const proxyUrl = `https://corsproxy.io/?` + encodeURIComponent(rawTelegramUrl);
            
            log("Fetching file via Proxy...", "info");
            const blob = await fetch(proxyUrl).then(r => {
                if(!r.ok) throw new Error("Proxy Download Failed");
                return r.blob();
            });

            // 3. Upload to Drive
            const fileName = fileObj.file_name || `upload_${Date.now()}.jpg`;
            const driveFile = await uploadToDrive(blob, fileName);

            // 4. Update DB
            const newEntry = {
                id: driveFile.id,
                name: fileName,
                url: `/drive-viewer?id=${driveFile.id}`,
                category: category,
                caption: caption,
                size: blob.size,
                date: Math.floor(Date.now() / 1000)
            };
            await updateDatabase(newEntry);

            log("‚úÖ Success!", "success");
            sendMessage(chatId, `‚úÖ <b>Uploaded Successfully!</b>\nSaved to: ${category}`, token);
        }

        async function uploadToDrive(blob, name) {
            const accessToken = gapi.client.getToken().access_token;
            const metadata = { name: name, parents: [DRIVE_FOLDER_ID] };
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', blob);

            log("Uploading to Google Drive...", "alert");
            const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id', {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + accessToken },
                body: form
            });
            return await res.json();
        }

        async function updateDatabase(newEntry) {
            log("Updating Database...", "info");
            const accessToken = gapi.client.getToken().access_token;
            
            // Fetch raw text to handle empty files
            const res = await fetch(`https://www.googleapis.com/drive/v3/files/${DB_FILE_ID}?alt=media`, {
                headers: { 'Authorization': 'Bearer ' + accessToken }
            });
            
            let dbText = await res.text();
            let db = [];
            try {
                db = dbText ? JSON.parse(dbText) : [];
            } catch(e) {
                console.log("DB Parse Error (resetting):", e);
                db = [];
            }
            
            if(!Array.isArray(db)) db = [];
            db.unshift(newEntry);

            await fetch(`https://www.googleapis.com/upload/drive/v3/files/${DB_FILE_ID}?uploadType=media`, {
                method: 'PATCH',
                headers: { 'Authorization': 'Bearer ' + accessToken, 'Content-Type': 'application/json' },
                body: JSON.stringify(db)
            });
        }

        function sendMessage(chatId, text, token) {
            fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ chat_id: chatId, text: text, parse_mode: 'HTML' })
            });
        }

        function log(msg, type) {
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            div.className = `log-entry ${type}`;
            document.getElementById('console').prepend(div);
        }
    </script>
</body>
</html>
